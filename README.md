# 진수변환 알고리즘(Casting Algorithm)

## 32비트 정수의 표현범위(이유 포함)
* 정수형 자료형은 크게 char, int 가 있으며 앞에 부호 키워드 (signed, unsigned) 와 크기(short, long)를 붙여서 특성을 정의할 수 있다.
  -	signed : 부호 있는 정수를 표현하고, 주로 생략한다.
  -	unsigned : 부호 없는 정수를 표현하고 값은 0부터 시작한다
- 여기서 쓰이는 32비트 정수의 표현범위는 signed int 자료형이며 크기는 4바이트, 32비트를 갖는다. 범위는 -2,147,483,648 ~ 2,147,483,647 (-2^31 ~ 2^31-1) 이다.
- 2^31-1 값은 소수이고, 가장 큰 값이며, 완전수를 넘는 마지막 값이다. 여기서 2^32에서 1을 뺀 이유는 0부터 시작하기 때문이다. 그리고 내가 생각하기로 이 표현범위를 사용하는 이유는 signed int 자료형을 사용하며, 이 자료형은 자료형이 가질 수 있는 크기 중 최상위 비트를 부호 판별용으로 쓰이기 때문에 이 표현범위를 사용한 것 같다.

## 진수변환 문제정의
- **먼저 10진수를 입력받아서 2진수로 변환하는 것**
  - 10진수가 양수일 때 : 입력받은 값을 2로 나눈 나머지 값을 32비트 2진수를 저장할 배열에 넣어주고 반복하여 입력받은 값을 2로 나눠주었다. 그렇게 하면 저장한 배열에는 역순으로 나머지가 저장되고 그것을 다시 반복문을 이용하여 출력해주었다
  - 10진수가 음수일 때 : 입력받은 값이 음수일 때는 음수 부호를 생략하고 2진수로 변형하고 1의 보수화를 해준 후 1을 더해주면 음수 2진수를 구할 수 있다. 2의보수를 계산할 때 Carry 값을 설정하여 캐리가 있으면 1 , 없으면 0으로 설정해주고 2의 보수를 계산한다.
- **10진수를 입력받아서 8진수로 변환하는 것**
  - 10진수가 양수일 때 : 나의 방법으로는 10진수를 2진수로 바꾼 것을 가지고 8진수로 바꾸어주었다. 32비트의 2진수를 3개씩 끊어주면서 더하고 그 값을 8진수를 담는 배열에 넣어주었다. 8진수는 0에서부터 7까지의 숫자만 사용한다는 점을 특징으로 갖고 있다.
  - 10진수가 음수일 때 : 2진수에서 구한 2의 보수를 이용하여 양수일 때와 같이 3개씩 끊어서 배열에 값을 저장해주었다.
- **10진수를 입력받아서 16진수로 변환하는 것**
  - 10진수가 양수 일 때 : 먼저 16진수에서 각 자리 수에 나타날 수 있는 수는 0부터 15까지이다. 다만 10부터 15까지의 수는 한 개로 된 숫자가 없으므로 문자를 사용하여 나타낸다. 10진수를 16으로 나누었을 때 생긴 몫을 계속 16으로 나누어주고 더 이상 몫이 생기지 않을 때까지 반복해주었다. 만약 몫이 16보다 작으면 더 이상 반복을 진행하지 않고, 배열에 저장된 값을 출력해준다
  - 10진수가 음수 일 때 : 8진수와 같은 방법으로 2의 보수를 이용하여 32비트를 4개씩 끊어서 더하여 배열에 값을 저장하고 출력해주었다.


![Alt text](/result1.png)
![Alt text](/result2.png)
